/*
CSP题目
问题描述：请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
　　假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，
	依次类推，第20排是96到100号。
　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，
	则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
　　假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。

输入格式：对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。
　　输入的第一行包含一个整数n，表示购票指令的数量。
　　第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。
输出格式
输出n行，每行对应一条指令的处理结果。
　　对于购票指令p，输出p张车票的编号，按从小到大排序。

样例输入
4
2 5 4 2
样例输出
1 2
6 7 8 9 10
11 12 13 14
3 4
*/
#include<stdio.h>

int main() {
	int seat[20][5] = {0};
	int surplus[20];	// 代表每排剩余的座位数
	for(int i=0; i<20; i++) surplus[i] = 5;
	
	int n = 0;
	scanf("%d", &n);
	int p = 0;
	for(int i=0; i<n; i++) {
		scanf("%d", &p);
		int j = 0;	// j代表第j排 
		while(j<20) {
			// 如果要购买的票数小于第j排的剩余票数
			if(p <= surplus[j]) {	
				surplus[j] -= p; 
				for(int k=0; k<5 && p>0; k++) {
					if(seat[j][k] == 0) {
						seat[j][k] = 1;
						p--;
						printf("%d ",j*5+k+1);
					}
				} 
			}
			j++;
		}
		// 如果不存在相邻位置 
		if(j == 20) {
			for(j=0; j<20; j++) {
				for(int k=0; k<5 && p>0; k++) {
					if(seat[j][k] == 0) {
						seat[j][k] = 1;
						p--;
						printf("%d ",j*5+k+1);
					}
				}
			} 
		}
		printf("\n");
	} 
}



